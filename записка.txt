МИНИСТЕРСТВО ОБРАЗОВАНИЯ РЕСПУБЛИКИ БЕЛАРУСЬ

Учреждение образования «БЕЛОРУССКИЙ ГОСУДАРСТВЕННЫЙ
ТЕХНОЛОГИЧЕСКИЙ УНИВЕРСИТЕТ»

Факультет          	Информационных Технологий					
Кафедра              	Программной инженерии						
Специальность 	6-05-0612-01 «Программная инженерия»				
Специализация 	Программирование обеспечение информационных технологий	

ПОЯСНИТЕЛЬНАЯ ЗАПИСКА
К КУРСОВОМУ ПРОЕКТУ НА ТЕМУ:

				«Разработка компилятора AVA-2025»			

Выполнил студент 			          Ародь Владислав Андреевич  	                                                                                                       
(Ф.И.О.)
Руководитель проекта 				ассистент Волчек Д. И.           	                                       
(учен. степень, звание, должность, подпись, Ф.И.О.)
Заведующий кафедрой 		   к.т.н., доц. Смелов Владимир Владимирович	
(учен. степень, звание, должность, подпись, Ф.И.О.)
Консультант 					ассистент Волчек Д. И.                   	
(учен. степень, звание, должность, подпись, Ф.И.О.)
Курсовой проект защищен с оценкой 						
















Минск 2025
 
	Содержание	
Введение	3
1. Спецификация языка программирования	4
1.1 Характеристика языка программирования	4
1.2 Алфавит языка	4
1.3 Применяемые сепараторы	4
1.4 Применяемые кодировки	5
1.5 Типы данных	5
1.6 Преобразование типов данных	6
1.7 Идентификаторы	6
1.8 Литералы	6
1.9 Объявления данных и область видимости	7
1.10 Инициализация данных	7
1.11 Инструкции языка	7
1.12 Операции языка	8
1.13 Выражения и их вычисления	8
1.14 Программные конструкции языка	9
1.15 Область видимости идентификаторов	10
1.16 Семантические проверки	10
1.17 Распределение оперативной памяти на этапе выполнения	10
1.18 Стандартные библиотеки и их состав	11
1.19 Ввод и вывод данных	12
1.20 Точка входа	12
1.21 Препроцессор	12
1.22 Соглашения о вызовах	12
1.23 Объектный код	12
1.24 Классификация сообщений транслятора	13
1.25 Контрольный пример	13
2. Структура транслятора	14
2.1 Компоненты транслятора, их назначение и принципы взаимодействия	14
2.2 Перечень входных параметров транслятора	15
2.3 Перечень протоколов, формируемых транслятором и их содержимое	16
3. Разработка лексического анализатора	17
3.1 Структура лексического анализатора	17
3.2. Контроль входных символов	18
3.3 Удаление избыточных символов	18
3.4 Перечень ключевых слов	19
3.5 Основные структуры данных	21
3.6 Принцип обработки ошибок	22
3.7 Структура и перечень сообщений лексического анализатора	22
3.8 Параметры лексического анализатора	22
3.9 Алгоритм лексического анализа	22
3.10 Контрольный пример	23
4. Разработка синтаксического анализатора	24
4.1 Структура синтаксического анализатора	24
4.2 Контекстно-свободная грамматика, описывающая синтаксис языка	24
4.3 Построение конечного магазинного автомата	26
4.4 Основные структуры данных	26
4.5 Описание алгоритма синтаксического разбора	27
4.6 Структура и перечень сообщений синтаксического анализатора	27
4.7. Параметры синтаксического анализатора и режимы его работы	27
4.8. Принцип обработки ошибок	28
4.9. Контрольный пример	28
5. Разработка семантического анализатора	29
5.1 Структура семантического анализатора	29
5.2 Функции семантического анализатора	29
5.3 Структура и перечень сообщений семантического анализатора	29
5.4 Принцип обработки ошибок	30
5.5 Контрольный пример	30
6. Вычисление выражений	31
6.1 Выражения, допускаемые языком	31
6.2 Польская запись и принцип её построения	31
6.3 Программная реализация обработки выражений	31
6.4 Контрольный пример	32
7. Генерация кода	33
7.1 Структура генератора кода	33
7.2 Представление типов данных в оперативной памяти	33
7.3 Статическая библиотека	34
7.4 Особенности алгоритма генерации кода	34
7.5 Входные параметры генератора кода	35
7.6 Контрольный пример	35
8. Тестирование транслятора	36
8.1 Тестирование проверки на допустимость символов	36
8.2 Тестирование лексического анализатора	36
8.3 Тестирование синтаксического анализатора	37
8.4 Тестирование семантического анализатора	38
Заключение	40
Список использованных источников	41
Приложение А	42
Приложение Б	43
Приложение В	44
Приложение Г	63
Приложение Д	66
Приложение Ж	70
 
Введение
В данном курсовом проекте поставлена задача разработки собственного языка программирования и транслятора для него. Название языка – AVA-2025. Написание транслятора осуществляется на языке C++, при этом код на языке AVA-2025 будет транслироваться в язык ассемблера. 
Задание на курсовой проект можно разделить на следующие задачи:
	  ¬¬¬¬¬¬¬¬¬¬– разработка спецификации языка AVA-2025;
– разработка лексического анализатора;
– разработка синтаксического анализатора;
– разработка семантического анализатора;
– разбор арифметических выражений;
– разработка генератора кода;
– тестирование транслятора;
Каждый из перечисленных этапов работы подробно рассмотрен в соответствующих разделах работы, начиная с описания синтаксиса языка и заканчивая генерацией в целевой язык Assembler.
 
1. Спецификация языка программирования
1.1	Характеристика языка программирования        
Язык программирования AVA-2025 является процедурным, строго типизируемым языком программирования, транслируемым в язык ассемблера (MASM - Microsoft Macro Assembler). Язык поддерживает три типа данных (number, line, char), функции с параметрами и возвращаемыми значениями, локальные переменные, циклы с фиксированным числом повторений и вызов функций стандартной библиотеки. Все программы на языке AVA-2025 должны содержать точку входа main.
1.2	Алфавит языка
Алфавит AVA-2025 состоит из символов, приведённых на Рисунке 1.1. Допустимо использование символов латинского алфавита (A…z), кириллицы (А…я). Запрещается использование служебных символов, а также некоторых символов. Например, использование знака тильды в AVA-2025 не предусмотрено.
1.3	Применяемые сепараторы
Сепараторы служат для разделения операций языка. Сепараторы, применяемые в языке программирования AVA-2025, приведены в таблице 1.1.
Таблица 1.1 - Применяемые сепараторы
Сепаратор	Назначение сепаратора
;	Разделитель инструкций
[]	Программный блок
( )	Параметры, приоритетность операций в выражениях
пробел	Допускается везде, кроме идентификаторов и ключевых слов. Служит для их разделения
,	Разделитель параметров в функции




Сепараторы – программные конструкции, позволяющие разделять программные блоки кода.
1.4	Применяемые кодировки 
Кодировка, используемая для написания программ на языке AVA-2025 - стандартная кодировка Windows-1251, представленная на Рисунке 1.2.
 
Рисунок 1.2 Таблица кодировки Windows 1251
Windows 1251 – это 8-битная кодировка символов, предназначенная для покрытия языков, использующих кириллицу.
1.5	Типы данных 
Допускается использование фундаментальных типов данных, определенных в таблице 1.2. 
Таблица 1.2 – Фундаментальные типы данных
Тип данных	Описание 
number	Фундаментальный тип данных. Предусмотрен для объявления целочисленных данных (2 байта). Максимальное значение: 65535, минимальное значение: -32768. Автоматически инициализируется нулевым значением.
line	Фундаментальный тип данных. Предусмотрен для объявления строк. (1 символ – 1 байт). Автоматическая инициализация строкой нулевой длины. Максимальное количество символов в строке – 255. Строка завершается нуль-терминатором.




Продолжение таблицы 1.2 
char	Фундаментальный тип данных. Предусмотрен для объявления символов (1 байт).
Эти типы данных позволяют выполнять множество операций и делают функционал языка шире
1.6 Преобразование типов данных
Преобразование типов данных в языке AVA-2025 не предусмотрено. Попытка преобразования типов данных приведет к ошибке.
1.7 Идентификаторы
Идентификаторы могут выступать в качестве имен функций, параметров, переменных. Зарезервированные идентификаторы не предусмотрены. Идентификаторы не должны совпадать с ключевыми словами.
Имя идентификатора составляется по следующим правилам:
– состоит из символов [a..z] и [A..Z] и цифр [0..9];
– длина идентификатора не должна превышать 16 символов. При превышении максимально допустимой длины применяется усечение.
Рекомендуется использовать осмысленные имена идентификаторов, отражающие назначение переменной или функции, что повышает читаемость программного кода.
1.8 Литералы
В языке программирования AVA-2025 предусмотрены целочисленные, строковые и символьные литералы. Все литералы являются rvalue. Их правила записи приведены в таблице 1.3.
Таблица 1.3 – Правила записи литералов
Тип литерала	Описание литерала
Символьный	Символ, заключенный в ' .. ' (одинарные кавычки).
Строковый	Символы, заключенные в "…" (двойные кавычки), число которых не превышает 255.
Целочисленный	AVA-2025 поддерживает представление литералов в следующих системах счисления:
десятичная: [0..9], без префикса;
шестнадцатеричная: [0..9], [A..F], начинается с префикса 'h'.
При выходе за пределы будет выброшена ошибка.
Литералы представляют неизменяемые значения. Литералы можно передавать переменным в качестве значения.
Rvalue – это выражение, которое не представляет собой объект, который занимает идентифицируемое место в памяти. 
Значения целочисленных литералов, выходящих за пределы допустимых значений (от -32768 до 65535) являются недопустимыми. Значения строковых литералов, у которых количество символов строки превышает 255 символов – автоматически урезается.
1.9 Объявления данных и область видимости
Для объявления переменной указывается тип данных, далее используется ключевое слово var, после чего имя идентификатора. Синтаксис: <тип данных> var <идентификатор>; или <тип данных> var <идентификатор> = <значение>;
Для объявления функций используется ключевое слово function, перед которым указывается тип возвращаемого значения функции (number, line, char или proc для функций без возвращаемого значения), а после – идентификатор функции. Синтаксис: <тип данных> function <идентификатор>([<тип данных> param <идентификатор>], ...)
Область видимости реализована Си-подобным образом: сверху-вниз. Все функции имеют глобальную область видимости и могут быть объявлены только в глобальной области видимости. Переменные объявляются внутри функций и имеют локальную область видимости. Параметры функций видны только внутри функции, в которой объявлены. Любые идентификаторы должны быть объявлены до их использования. 
1.10 Инициализация данных
Объектами-инициализаторами могут быть только идентификаторы или литералы. Также возможна инициализация непосредственно при объявлении переменной. Пример инициализации данных представлен в листинге 1.1.
number var x = 5;
line var sone = "hello";
char var c = 'b';
Листинг 1.1 – Инициализация данных в языке AVA-2025
При объявлении предусмотрены значения по умолчанию: значение 0 для типа number, строка длины 0 ("") для типа line, а также значение 0 для символьного типа данных.
1.11 Инструкции языка
В языке программирования AVA-2025 применяются инструкции, представленные в таблице 1.4.
Таблица 1.4 – Инструкции языка
Инструкция языка	Синтаксис
Объявление переменной	<тип данных> var <идентификатор>;
<тип данных> var <идентификатор> = <литерал>|<выражение>|<идентификатор>;
Присваивание	<идентификатор> = <литерал>|<выражение>|<идентификатор>;
Вызов функций	<идентификатор функции> ([параметр 1] [, параметр 2]);
Вывод данных в консоль	print <идентификатор>|<литерал>; writeline;
Унарные операции	inc <идентификатор>; (инкремент)
dec <идентификатор>; (декремент)
inv <идентификатор>; (инверсия)
Возврат из функции	return <литерал>|<идентификатор>;

Оператор цикла	cycle <целочисленный литерал>|<идентификатор типа number> [ <тело цикла> ]
Цикл выполняется указанное количество раз. Используется регистр CX для подсчета итераций.
1.12 Операции языка
Язык программирования AVA-2025 может выполнять арифметические операции, побитовые операции и унарные операции, представленные в таблице 1.5.
Таблица 1.5 - Приоритетности операций языка программирования AVA-2025
Операция	Арифметическое назначение	Приоритетность операции
()	Приоритетность операций	1
+	Сложение	3
-	Вычитание	3
*	Умножение	4
/	Деление	4
%	Взятие остатка от деления	4
{	Побитовый сдвиг влево	5
}	Побитовый сдвиг вправо	5
inc	Унарная операция инкремент (увеличение на 1)	-
dec	Унарная операция декремент (уменьшение на 1)	-
inv	Унарная операция инверсия (побитовое НЕ)	-
Для повышения приоритетности следует использовать круглые скобки. Унарные операции применяются к переменным типа number и выполняются до выполнения арифметических операций. 
1.13 Выражения и их вычисления 
Выражения относятся только к целочисленному типу (number). Выражения могут содержать арифметические операции, побитовые сдвиги и вызовы функций, возвращающих целочисленное значение.
Предусмотрены следующие правила составления выражений: 
– выражения записываются до ввода сепаратора «;»;
– выражение может содержать вызов функций, возвращающих целочисленное значение;
– операции рассматриваются в соответствии с их приоритетом;
– для изменения приоритета операций используются круглые скобки ();
– реализация выражений происходит с помощью обратной польской записи (ПОЛИЗ).
Данные правила формируют основу для синтаксического и семантического анализа выражений, что позволяет обеспечить корректную обработку арифметических конструкций в языке AVA‑2025.
1.14 Программные конструкции языка
Программные конструкции представлены в таблице 1.6.
Таблица 1.6 – Программные конструкции языка
Конструкция	Представление в языке
Главная функция	main
[
<инструкции языка>
]
Цикл	cycle <целочисленный литерал>|<идентификатор типа number> [
<инструкции языка>
]
Цикл выполняется указанное количество раз. Используется регистр CX для подсчета итераций и инструкция loop для организации цикла.


Продолжение таблицы 1.6
Функция	<тип данных> function <идентификатор>([<тип данных> param <идентификатор>], [<тип данных> param <идентификатор>])
[
<инструкции языка>
return <идентификатор>|<литерал>
]
Программные конструкции языка AVA-2025 представляют собой базовый функционал для выполнения различных операций. Язык поддерживает процедурное программирование с локальными переменными, функциями с параметрами и возвращаемыми значениями, циклами с фиксированным числом повторений, что делает возможным решать задачи различного уровня сложности.
1.15 Область видимости идентификаторов
Все переменные, объявленные внутри функции с помощью ключевого слова var, являются локальными и видны только внутри этой функции. Параметры функций видны только внутри функции, в которой объявлены. Функции имеют глобальную область видимости и могут быть вызваны из любой части программы после их объявления. Глобальные переменные не поддерживаются - все переменные должны быть объявлены внутри функций.
1.16 Семантические проверки
Перечень семантических проверок, предусмотренных языком:
– деление на ноль;
– совпадение типов данных;
– корректность строковых выражений справа от знака равно;
– проверка на возвращаемое значение из функции;
– передаваемые параметры в функции при вызове;
– переопределение типов данных;
– выход за пределы области видимости;
– усечение слишком длинного значения line-литерала;
– точка входа main;
– проверка типа идентификаторов;
–	проверка лексем
Если ошибка возникает на этапе лексического анализа, синтаксический анализ не выполняется. В случае, когда три подряд идущие фразы не удаётся разобрать, работа транслятора прекращается. Если же ошибка появляется в процессе синтаксического анализа, проблемная фраза игнорируется (считается отсутствующей), после чего выполняется попытка разобрать следующую фразу. Границей фразы считается точка с запятой.
Назначение семантического анализа – проверка смысловой правильности конструкций языка программирования.
1.17 Распределение оперативной памяти на этапе выполнения
Транслированный код использует три сегмента памяти:
– сегмент .const (константы) - в него заносятся все литералы (строковые, символьные, целочисленные);
– сегмент .data (данные) - в него заносятся переменные и параметры функций;
– сегмент .code (код) - содержит исполняемый код программы и функций.
Локальная область видимости переменных в исходном коде обеспечивается за счет использования префиксов имен переменных, включающих имя функции, в которой они объявлены (например, mainx, mainy для переменных в функции main).
1.18 Стандартные библиотеки и их состав
В языке AVA-2025 присутствует стандартная статическая библиотека StaticLibrary, подключается автоматически при трансляции кода в ассемблер. Функции стандартной библиотеки и их описание представлено в таблице 1.7.

Таблица 1.7 - Библиотека StaticLibrary языка AVA-2025
Имя функции	Возвращаемое значение	Принимаемые параметры	Описание
outlich	integer	integer value - целое число	Функция выводит на консоль целочисленное значение value типа number. Используется для вывода чисел.

outrad	integer	char* ptr - указатель на строку	Функция выводит на консоль строку, на которую указывает ptr. Используется для вывода строк типа line и символов типа char. Если ptr равен NULL, выводит пустую строку.

compare	integer	char* ptr - буфер, char* a - строка 1, char* b - строка 2	Функция сравнивает две строки лексикографически и возвращает: 0 если a < b, 1 если a == b, 2 если a > b. Используется для сравнения строк типа line.

slength	integer	char* buffer - буфер, char* str - строка	Функция вычисляет длину строки str (до нуль-терминатора). Возвращает количество символов в строке.
copystr	char*	char* buffer - буфер, char* str - строка	Функция копирует строку str в буфер buffer (максимум 255 символов) и возвращает указатель на буфер. Используется для копирования строк.
rnd	integer	char* ptr - буфер, int a - начало диапазона, int b - конец диапазона	Функция генерирует случайное числовое значение в диапазоне от a до b включительно. Использует текущее время как seed для генератора случайных чисел.
Стандартная библиотека AVA-2025 содержит 6 функций, использование которых упрощает написание кода. Все функции используют соглашение вызова __stdcall, что обеспечивает корректную передачу параметров из ассемблерного кода.
1.19 Ввод и вывод данных
Ввод данных в языке AVA-2025 не предусмотрен. Вывод данных осуществляется с помощью ключевых слов «print» и «writeline». 
Ключевое слово «print» выводит значение переменной или литерала. Поддерживается вывод:
– целочисленных значений типа number (через функцию outlich);
– строк типа line (через функцию outrad);
– символов типа char (через функцию outrad).
Ключевое слово «writeline» переводит курсор на новую строку (выводит символы перевода строки через функцию outrad).
Синтаксис: print <идентификатор>|<литерал>; writeline;
1.20 Точка входа
Точкой входа в программе является ключевое слово «main». Точка входа не может отсутствовать или быть переопределена.
1.21 Препроцессор
Препроцессор в языке программирования AVA-2025 не предусмотрен.
1.22 Соглашения о вызовах 
Используется соглашение stdcall, все параметры передаются в стек справа налево, память освобождается вызываемым кодом.
1.23 Объектный код  
Язык AVA-2025 транслируется в исходный код для языка ассемблера (MASM - Microsoft Macro Assembler). Генерируемый код использует модель памяти flat и соглашение вызова stdcall.
1.24 Классификация сообщений транслятора
Классификация ошибок представлена в таблице 1.8.
Таблица 1.8 - Классификация ошибок
Номера ошибок	Характеристика
0 – 99	Системные ошибки
100 – 104	Ошибки входных параметров
105 – 109	Ошибки при открытии файла
110 – 119	Ошибки при чтении файла
200 – 299	Ошибки лексического анализа (200-204, 312)
300 – 399	Ошибки синтаксического анализа (300-306, 310-311, 313, 319)
600 – 611	Ошибки синтаксического анализа грамматики (правила S, P, T, G, E, F, N, A, V, W, K, X)
307 – 309, 314 – 318, 612 – 615	Ошибки семантического анализа
Обрабатываются ошибки на всех этапах обработки исходного кода, то есть во время прохождения различных этапов анализа.
1.25 Контрольный пример
Контрольный пример демонстрирует некоторые особенности языка AVA-2025: его фундаментальные типы, основные структуры, использование пользовательских функций, использование функций статической библиотеки, программные конструкции языка. Исходный код контрольного примера представлен в приложении А. 










2. Структура транслятора
2.1 Компоненты транслятора, их назначение и принципы взаимодействия
В языке AVA-2025 исходный код транслируется в язык Assembler. Транслятор языка разделён на отдельные части, которые взаимодействуют между собой и выполняют отведённые им функции, которые представлены в пункте 2.1. Для того чтобы получить ассемблерный код, используется выходные данные работы лексического анализатора, а именно таблица лексем и таблица идентификаторов. Для указания выходных файлов используются входные параметры транслятора, которые описаны в таблице 2.1. Структура транслятора языка AVA-2025 приведена на рисунке 1. 
 
     Рисунок 2.1 – Структура транслятора языка AVA-2025
Первая стадия работы компилятора называется лексическим анализом, а программа, её реализующая, – лексическим анализатором (лексер). На вход лексического анализатора подаётся последовательность символов входного языка. Он производит предварительный разбор текста, преобразующий единый массив текстовых символов в массив отдельных слов (в теории компиляции вместо термина «слово» часто используют термин «токен»). Примеры лексических единиц: идентификаторы, числа, символы операций, служебные слова и т.д. Лексический анализатор преобразует исходный текст, заменяя лексические единицы их внутренним представлением – лексемами, для создания промежуточного представления исходной программы. Каждой лексеме сопоставляется ее тип и запись в таблице идентификаторов, в которой хранится дополнительная информация. Таблица лексем (ТЛ) и таблица идентификаторов (ТИ) являются входом для следующей фазы компилятора – синтаксического анализа.

Лексический анализатор, последовательно обрабатывая входной поток символов, выделяя из него значимые элементы языка и подготавливая их к дальнейшим этапам трансляции, выполняет следующие функции:
− убрать все лишние пробелы; 
− выполнить распознавание лексем; 
− построить таблицу лексем и таблицу идентификаторов; 
− при неуспешном распознавании или обнаружении некоторых ошибок во входном тексте выдать сообщение об ошибке.
Синтаксический анализатор – часть компилятора, выполняющая синтаксический анализ, то есть проверку исходного кода на соответствие правилам грамматики. Входной информацией для синтаксического анализа является таблица лексем и таблица идентификаторов. Выходной информацией является дерево разбора
Семантический анализатор – часть транслятора, выполняющая семантический анализ, то есть проверку исходного кода на наличие ошибок, которые невозможно отследить при помощи регулярной и контекстно-свободной грамматики. Входными данными являются таблица лексем и идентификаторов.
Генератор кода – часть транслятора, выполняющая генерацию ассемблерного кода на основе полученных данных на предыдущих этапах трансляции. На вход генератора подаются таблица лексем и таблица идентификаторов, на основе которых генерируется файл с ассемблерным кодом.
2.2 Перечень входных параметров транслятора
Для формирования файлов с результатами работы лексического, синтаксического и семантического анализаторов используются входные параметры транслятора, которые приведены в таблице 2.1.
Таблица 2.1 - Входные параметры транслятора языка AVA-2025  
Входной параметр	Описание параметра	Значение по умолчанию
-in:<путь к in-файлу>	Файл с исходным кодом на языке AVA-2025 , имеющий расширение .txt	Не предусмотрено
-log:<путь к log-файлу>	Файл журнала для вывода протоколов работы программы.	Значение по умолчанию:
<имя in-файла>.log



Продолжение таблицы 2.1
-out:<путь к out-файлу>	Выходной файл – результат работы транслятора. Содержит исходный код на языке асемблера.	Значение по умолчанию:
<имя in-файла>.asm
Входные параметры указываются через командную строку вручную.
2.3 Перечень протоколов, формируемых транслятором и их содержимое
В ходе работы программы формируются протоколы работы лексического, синтаксического и семантического анализаторов, которые содержат в себе перечень протоколов работы. В таблице 2.2 приведены протоколы, формируемые транслятором и их содержимое.
Таблица 2.2 - Протоколы, формируемые транслятором языка AVA-2025 
Формируемый протокол	Описание выходного протокола
Файл журнала, заданный параметром "-log:"	Файл с протоколом работы транслятора языка программирования AVA-2025. Содержит информацию про входные параметры, общем количестве символов и строк(исходные данные), протокол работы синтаксического анализатора, полученный на этапе синтаксического анализа.

Выходной файл с названием "Table.id.txt"	Файл содержит таблицу идентификаторов, сформированную во время лексического анализа. 
Выходной файл с названием "Table.lex.txt"	Файл содержит таблицу лексем, сформированную во время лексического анализа.
Выходной файл, заданный параметром "-out:"	Результат работы программы – файл, содержащий исходный код на языке ассемблера. 

Все файлы создаются в каталоге, относительно исполняемого модуля.
 
3. Разработка лексического анализатора
3.1 Структура лексического анализатора
Первая стадия работы компилятора называется лексическим анализом, а программа, её реализующая, – лексическим анализатором (лексером). На вход лексического анализатора подаётся исходный код входного языка. Лексический анализатор выделяет в этой последовательности простейшие конструкции языка. Лексический анализатор производит предварительный разбор текста, преобразующий единый массив текстовых символов в массив токенов. 
Примеры лексических единиц: идентификаторы, числа, символы операций, служебные слова и т.д. Лексический анализатор преобразует исходный текст, заменяя лексические единицы их внутренним представлением – лексемами, для создания промежуточного представления исходной программы. Каждой лексеме сопоставляется ее тип и запись в таблице идентификаторов, в которой хранится дополнительная информация. 
Функции лексического анализатора:
– удаление «пустых» символов и комментариев. Если «пустые» символы (пробелы, знаки табуляции и перехода на новую строку) и комментарии будут удалены лексическим анализатором, синтаксический анализатор никогда не столкнется с ними (альтернативный способ, состоящий в модификации грамматики для включения «пустых» символов и комментариев в синтаксис, достаточно сложен для реализации);
– распознавание идентификаторов и ключевых слов;
– распознавание констант;
– распознавание разделителей и знаков операций.
Исходный код программы представлен в приложении А, структура лексического анализатора представлена на рисунке 3.1.

 
Рисунок 3.1 – Структура лексического анализатора
Лексический анализ служит фундаментом для последующих этапов компиляции, обеспечивая синтаксическому анализатору корректную и структурированную последовательность токенов. Качество работы лексера напрямую влияет на точность разбора и дальнейшую обработку программы.
3.2. Контроль входных символов
Для удобной работы с исходным кодом, при передаче его в лексический анализатор, все символы разделяются по категориям. Таблица входных символов представлена на рисунке 3.1. 
 
Рисунок 3.1 – Таблица контроля входных символов
Категории входных символов представлены в таблице 3.2. 
Таблица 3.2 - Соответствие символов и их значений в таблице
Значение в таблице входных символов	Символы
Разрешенный	T
Запрещенный	F
Игнорируемый	I
Пробел, табуляция	S
Операторы	V
Цифры	N
Также лексический анализатор осуществляет контроль допустимости входных символов, классифицируя их по типам: разрешённые, запрещённые, игнорируемые и т.д. Это позволяет заранее исключить недопустимые символы и упростить дальнейшую обработку исходного кода.
3.3 Удаление избыточных символов
Избыточными символами являются символы табуляции и пробелы.
Избыточные символы удаляются на этапе разбиения исходного кода на токены.
Описание алгоритма удаления избыточных символов:
– посимвольно считываем файл с исходным кодом программы;
– встреча пробела или знака табуляции является своего рода встречей символа-сепаратора;
– в отличие от других символов-сепараторов не записываем в очередь лексем эти символы, т.е. игнорируем.
Удаление избыточных символов позволяет упростить структуру входного потока и избежать обработки нерелевантных данных на последующих этапах компиляции. Такой подход повышает эффективность лексического анализа и снижает вероятность синтаксических ошибок, связанных с лишними пробелами или табуляцией.
3.4 Перечень ключевых слов
Лексический анализатор преобразует исходный текст, заменяя лексические единицы лексемами для создания промежуточного представления исходной программы. Соответствие токенов и лексем приведено в таблице 3.2.
Таблица 3.2 - Соответствие токенов и сепараторов с лексемами
Токен	Лексема	Пояснение
number	t	Название целочисленного типа данных (2 байта).
line	t	Название строкового типа данных.
char	c	Название символьного типа данных.
Идентификатор	i	Длина идентификатора – 16 символов.
Литерал 	l	Литерал строкового и целочисленного типа данных.
Литерал	k	Литерал для символьного типа данных.
function 	f	Объявление функции.
var	n	Объявление переменной
param	p	Объявление параметра функции
return	e	Выход из функции/процедуры.
main	m	Главная функция.
print	o	Вывод данных
writeline	^	Перевод курсора на новую строку
inc	u	Унарная операция инкремент
dec	v	Унарная операция декремент
inv	x	Унарная операция инверсия
cycle	c	Оператор цикла
;	;	Разделение выражений.
,	,	Разделение параметров функций.
[	[	Начало блока/тела функции.
]	]	Закрытие блока/тела функции.
Продолжение таблицы 3.2
)	)	Закрытие блока для передачи параметров, приоритет операций.
=	=	Знак присваивания.
+
-
*
/
%	#	Знаки операций.
>
<
^
&	>
<
^
&	Знаки логических операторов.
{
}	b
n	Знаки побитовых сдвигов.
#	Нет	Комментарии.
(	(	Передача параметров в функцию, приоритет операций.
Пример реализации таблицы лексем представлен в приложении Б.
Каждому выражению соответствует детерминированный конечный автомат, по которому происходит разбор данного выражения. На каждый автомат в массиве подаётся токен и с помощью регулярного выражения, соответствующего данному графу переходов, происходит разбор. В случае успешного разбора выражения оно записывается в таблицу лексем. Если выражение является идентификатором или литералом, информация также заносится в таблицу идентификаторов. Дополнительно использование единой таблицы ключевых слов обеспечивает однозначность интерпретации конструкций языка и исключает неоднозначности при разборе. Благодаря применению детерминированных конечных автоматов процесс лексического анализа становится формально описанным, воспроизводимым и легко расширяемым при добавлении новых элементов языка. Такой подход обеспечивает строгий контроль корректности входных данных и позволяет своевременно выявлять лексические ошибки ещё до этапа синтаксического анализа. В результате повышается надёжность всей системы компиляции и упрощается последующая обработка программы. Структура конечного автомата изображена на рисунке 3.3.
 
               Рисунок 3.3 – Структура конечного автомата
Пример графа перехода конечного автомата изображен на рисунке 3.4.
 
Рисунок 3.4 – Пример реализации графа КА для токена main
3.5 Основные структуры данных
Основными структурами данных лексического анализатора являются таблица лексем и таблица идентификаторов. Таблица лексем представляет собой последовательность записей, каждая из которых содержит номер лексемы, саму лексему (lexema), полученную в результате разбиения исходного кода, знак оператора (sign), номер строки в исходном файле (sn), номер токена (st), а также индекс в таблице идентификаторов (idxTI), если текущая лексема относится к идентификаторам. Такая структура позволяет не только хранить результаты лексического анализа, но и обеспечивать удобный доступ к информации на последующих этапах компиляции, включая синтаксический и семантический анализ. Таблица идентификаторов, в свою очередь, содержит дополнительные сведения об именах переменных, функций и других сущностей, что делает её важным элементом для проверки корректности программы. Код C++ со структурой таблицы лексем представлен на рисунке 3.5.
 
Рисунок 3.5 – Структура таблицы лексем
Таблица идентификаторов содержит имя идентификатора (id), номер в таблице лексем (idxfirstLE), тип данных (iddatatype), тип идентификатора (idtype) и значение (или параметры функций) (value). Код C++ со структурой таблицы идентификаторов представлен на рисунке 3.6.
 
Рисунок 3.6 – Структура таблицы идентификаторов
Совместное использование таблицы лексем и таблицы идентификаторов обеспечивает целостное и структурированное представление исходной программы, позволяя эффективно передавать результаты лексического анализа на последующие этапы обработки. Благодаря такой организации данных компилятор получает возможность быстро обращаться к необходимой информации, что повышает производительность и надёжность всего процесса трансляции.
3.6 Принцип обработки ошибок
Для обработки ошибок лексический анализатор использует таблицу с сообщениями. Структура сообщений содержит информацию о номере сообщения, номер строки и позицию, где было вызвано сообщение в исходном коде. Перечень сообщений представлен на рисунке 3.7.
 
Рисунок 3.7 – Сообщения лексического анализатора
При возникновении ошибки, лексический анализатор выбрасывает исключение – работа программы останавливается.
3.7 Структура и перечень сообщений лексического анализатора 
Ошибки, возникающие в процессе трансляции программы, фиксируются в протокол, заданный входным параметрами. В случае возникновения ошибок происходит их протоколирование с номером ошибки и диагностическим сообщением.
3.8 Параметры лексического анализатора 
Результаты работы лексического анализатора, а именно таблицы лексем и идентификаторов выводятся в два отдельных файла – lextable.txt и idtable.txt.
3.9 Алгоритм лексического анализа
	Алгоритм лексического анализа следующий:
– проверяет входной поток символов программы на исходном языке на допустимость, удаляет лишние пробелы и добавляет сепаратор для вычисления номера строки для каждой лексемы;
– для выделенной части входного потока выполняется функция распознавания лексемы; 
– при успешном распознавании информация о выделенной лексеме заносится в таблицу лексем и таблицу идентификаторов, и алгоритм возвращается к первому этапу;
– формирует протокол работы;
– при неуспешном распознавании выдается сообщение об ошибке.

 
Рисунок 3.2 Пример графа переходов для цепочки number
Распознавание цепочек основывается на работе конечных автоматов. Работу конечного автомата можно проиллюстрировать с помощью графа переходов. Пример графа для цепочки «number» представлен на рисунке 3.2, где S0 – начальное, а S6 – конечное состояние автомата.
3.10 Контрольный пример
Результат работы лексического анализатора в виде таблиц лексем и идентификаторов, соответствующих контрольному примеру, представлен в приложении Б. 
4. Разработка синтаксического анализатора
4.1 Структура синтаксического анализатора
Синтаксический анализатор: часть компилятора, выполняющая синтаксический анализ, то есть исходный код проверяется на соответствие правилам грамматики. 
Описание структуры синтаксического анализатора языка представлено на рисунке 4.1.
 
Рисунок 4.1 – Структура синтаксического анализатора
Входной информацией для синтаксического анализа является таблица лексем и таблица идентификаторов. Выходной информацией– дерево разбора
4.2 Контекстно-свободная грамматика, описывающая синтаксис языка
В синтаксическом анализаторе транслятора языка AVA-2025 используется контекстно-свободная грамматика  , где
T – множество терминальных символов (было описано в разделе 1.2 данной пояснительной записки), 
N – множество нетерминальных символов (первый столбец таблицы 4.1), 
P – множество правил языка (второй столбец таблицы 4.1), 
S – начальный символ грамматики, являющийся нетерминалом. 
Эта грамматика имеет нормальную форму Грейбах, т.к. она не леворекурсивная (не содержит леворекурсивных правил) 
Описание нетерминальных символов содержится в таблице 4.1.
Таблица 4.1 - Таблица правил переходов нетерминальных символов
Символ	Правила	Какие правила порождает
S	S-> tfi(P)T S
S-> pfi(P)G S	Стартовые правила, описывающие общую структуру программы 
Продолжение таблицы 4.1
	S-> m[K]	
T	T-> [e V;]
T-> [K e V;]	Тело функции с возвращаемым значением
G	G-> [e;]
G-> [K e;]	Тело функции без возвращаемого значения
P	P-> (E)
P-> ()	Параметры функции
E	E-> ti
E-> ti,E	Список параметров функции
F	F-> (N)
F-> ()	Аргументы вызова функции
N	N-> i
N-> l
N-> i,N
N-> l,N	Список аргументов функции
A	A-> +
A-> -
A-> *
A-> /
A-> %
A-> }
A-> {	Арифметические операции и побитовые сдвиги
V	V-> l
V-> i
V-> h	Значение для возврата
W	W-> i
W-> l
W-> (W)
W-> (W)A W
W-> i(F)
W-> i A W
W-> l A W
W-> i(F) A W	Выражения: идентификаторы, литералы, вызовы функций, операции
K	K-> nti=V;K
K-> nti;K
K-> i=W;K
K-> oV;K
K-> ^;K
K-> i(F);K
K-> u i;K
K-> v i;K
K-> x i;K
K-> cV[K]K
K-> nti=V;
K-> i=W;
K-> nti;
K-> oV;
K-> ^;
K-> i(F);
K-> u i;
K-> v i;
K-> x i;
K-> cV[K]	Операторы: объявления, присваивания, вызовы, унарные операции, циклы
X	X-> i=W;X
X-> oV;X
X-> ^;X
X-> i(F);X
X-> u i;X
X-> v i;X
X-> x i;X
X-> cV[X]X
X-> i=W;
X-> oV;
X-> ^;
X-> i(F);
X-> u i;
X-> v i;
X-> x i;
X-> cV[X]	Операторы для функций без возвращаемого значения
На основе представленной грамматики синтаксический анализатор строит дерево разбора, последовательно применяя правила вывода к входной последовательности токенов. Такая формальная структура позволяет однозначно интерпретировать каждую конструкцию языка AVA‑2025 и обеспечивает корректный переход к этапу семантического анализа.
4.3 Построение конечного магазинного автомата
Конечный автомат с магазинной памятью представляет собой семерку . Подробное описание компонентов магазинного автомата представлено в таблице 4.2. 
Таблица 4.2 – Описание компонентов магазинного автомата
Компонента	Определение	Описание
 	Множество состояний автомата	Состояние автомата представляет из себя структуру, содержащую позицию на входной ленте, номера текущего правила и цепочки и стек автомата
 	Алфавит входных символов	Алфавит представляет из себя множества терминальных и нетерминальных символов, описание которых содержится в таблица 3.1 и 4.1.
 	Алфавит специальных магазинных символов	Алфавит магазинных символов содержит стартовый символ и маркер дна стека (представляет из себя символ $)
 	Функция переходов автомата	Функция представляет из себя множество правил грамматики, описанных в таблице 4.1.
 	Начальное состояние автомата	Состояние, которое приобретает автомат в начале своей работы. Представляется в виде стартового правила грамматики
 	Начальное состояние магазина автомата	Символ маркера дна стека $
 	Множество конечных состояний	Конечные состояние заставляют автомат прекратить свою работу. Конечным состоянием является пустой магазин автомата и совпадение позиции на входной ленте автомата с размером ленты
Совокупность перечисленных элементов определяет поведение магазинного автомата и задаёт правила обработки входной строки с учётом содержимого стека. Благодаря такой структуре автомат способен распознавать контекстно свободные языки, что делает его подходящим инструментом для реализации синтаксического анализа в трансляторе.
4.4 Основные структуры данных
Основные структуры данных синтаксического анализатора представляются в виде структуры магазинного конечного автомата, выполняющего разбор исходной ленты, и структуры грамматики Грейбах, описывающей синтаксические правила языка AVA-2025. Данные структуры в приложении В.
4.5 Описание алгоритма синтаксического разбора
Принцип работы автомата, следующий:
– в магазин записывается стартовый символ; 
– на основе полученных ранее таблиц формируется входная лента;
– запускается автомат;
– выбирается цепочка, соответствующая нетерминальному символу, записывается в магазин в обратном порядке;
– если терминалы в стеке и в ленте совпадают, то данный терминал удаляется из ленты и стека. Иначе возвращаемся в предыдущее сохраненное состояние и выбираем другую цепочку нетерминала; 
– если в магазине встретился нетерминал, переходим к пункту 4;
– если наш символ достиг дна стека, и лента в этот момент пуста, то синтаксический анализ выполнен успешно. Иначе генерируется исключение.
Такой алгоритм обеспечивает детерминированный и воспроизводимый процесс разбора, позволяя однозначно установить корректность структуры входной программы.
4.6 Структура и перечень сообщений синтаксического анализатора 
Перечень сообщений синтаксического анализатора представлен на рисунке 4.3. 
 
Рисунок 4.3 Сообщения синтаксического анализатора
На этапе синтаксического анализа определено 11 потенциально возможных ошибок, каждая из которых обрабатывается и в случае возникновения – срабатывает и выводится.
4.7. Параметры синтаксического анализатора и режимы его работы 
Входной информацией для синтаксического анализатора является таблица лексем и идентификаторов. Кроме того, используется описание грамматики в форме Грейбах. Результаты работы лексического разбора, а именно дерево разбора и протокол работы автомата с магазинной памятью выводятся в журнал работы программы.
4.8. Принцип обработки ошибок 
Синтаксический анализатор выполняет разбор исходной последовательности лексем до тех пор, пока не дойдёт до конца цепочки лексем или не найдёт ошибку. Тогда анализ останавливается и выводится сообщение об ошибке (если она найдена). Если в процессе анализа находятся более трёх ошибок, то анализ останавливается.
4.9. Контрольный пример 
Результаты работы лексического разбора, а именно дерево разбора и протокол работы автомата с магазинной памятью приведены в приложении В.
 
5. Разработка семантического анализатора
5.1 Структура семантического анализатора
Семантический анализатор принимает на свой вход результаты работ лексического и синтаксического анализаторов, то есть таблицы лексем, идентификаторов и результат работы синтаксического анализатора, то есть дерево разбора, и последовательно ищет необходимые ошибки. Некоторые проверки (такие как проверка на единственность точки входа, проверка на предварительное объявление переменной) осуществляются в процессе лексического анализа. Общая структура обособленно работающего (не параллельно с лексическим анализом) семантического анализатора представлена на рисунке 5.1.
 
Рисунок 5.1 Структура семантического анализатора
5.2 Функции семантического анализатора
Семантический анализатор выполняет проверку на основные правила языка (семантики языка), которые описаны в разделе 1.16.
5.3 Структура и перечень сообщений семантического анализатора
Сообщения, формируемые семантическим анализатором, представлены на рисунке 5.1.

 

Рисунок 5.1 Перечень сообщений семантического анализатора.

На этапе семантического анализа предусмотрено возникновение 12 возможных ошибок.
5.4 Принцип обработки ошибок
Ошибки, возникающие в процессе трансляции программы, фиксируются в протокол, заданный входным параметрами. В случае возникновения ошибок происходит их протоколирование с номером ошибки и диагностическим сообщением.
5.5 Контрольный пример
Соответствие примеров некоторых ошибок в исходном коде и диагностических сообщений об ошибках приведено в таблице 5.1.
Таблица 5.1 - Примеры диагностики ошибок
Исходный код	Текст сообщения
main[
	number var x = 15;
x = x + "string";
]	Ошибка на этапе Семантического анализатора
Ошибка 314: Семантический анализ: несоответствие типов данных при присваивании, строка 3
main[
number var x;
x = 5 / 0;
]	Ошибка на этапе Семантического анализатора
Ошибка 318: Семантический анализ: деление на ноль, строка 3
main[
	line var y;
y = "test2" + "test3";
]	Ошибка на этапе Семантического анализатора
Ошибка 316: Семантический анализ: недопустимая операция со строковым типом, строка 3
Общая информация про ошибки выводится непосредственно в консоль и текстовый файл. 
6. Вычисление выражений
6.1 Выражения, допускаемые языком
В языке AVA-2025 допускаются вычисления выражений целочисленного типа данных с поддержкой вызова функций внутри выражений. Приоритет операций представлен на таблице 6.1. 
Таблица 6.1 - Приоритеты операций
Операция	Значение приоритета
( )	1 (наивысший)
*	4
/	4
%	4
{	5
}	5
+	3
-	3
Операции с одинаковым приоритетом выполняются слева направо. Для изменения порядка выполнения используются круглые скобки.
6.2 Польская запись и принцип её построения
Все выражения языка AVA-2025 преобразовываются к обратной польской записи.
Польская запись – это альтернативный способ записи арифметических выражений, преимущество которого состоит в отсутствии скобок. Существует два типа польской записи: прямая и обратная, также известные как префиксная и постфиксная. Отличие их от классического, инфиксного способа заключается в том, что знаки операций пишутся не между, а, соответственно, до или после аргументов. Алгоритм построения польской записи:
– исходная строка: выражение;
– результирующая строка: польская запись; 
– стек: пустой;
– исходная строка просматривается слева направо;
– операнды переносятся в результирующую строку;
– операция записывается в стек, если стек пуст;
– операция выталкивает все операции с большим или равным приоритетом в результирующую строку;
– отрывающая скобка помещается в стек;
– закрывающая скобка выталкивает все операции до открывающей скобки, после чего обе скобки уничтожаются.
6.3 Программная реализация обработки выражений
Программная реализация алгоритма преобразования выражений к польской записи представлена в приложении Г.
6.4 Контрольный пример
Пример преобразования выражений из контрольных примеров к обратной польской записи представлен в таблице 6.2. 
Таблица 6.2 - Преобразование выражений к ПОЛИЗ
Выражение	Обратная польская запись для выражения
l	l
i+l	il+
i*l	il*
ПОЛИЗ, или, как её еще называют, обратная польская запись, это способ бесско¬боч¬ного представления выражений (не только арифметических), в которых операнды пред¬шествуют операции. 
7. Генерация кода
7.1 Структура генератора кода
В языке AVA-2025 генерация кода является заключительным этапом трансляции. Генератор принимает на вход таблицы лексем и идентификаторов, полученные в результате лексического анализа. В соответствии с таблицей лексем строится выходной файл на языке ассемблера, который будет являться результатом работы транслятора. В случае возникновения ошибок генерация кода не будет осуществляться. Структура генератора кода AVA-2025 представлена на рисунке 7.1.
 
Рисунок 7.1 Структура генератора кода
Такое построение генератора кода обеспечивает последовательное и корректное преобразование промежуточного представления программы в итоговый ассемблерный код. Благодаря модульной архитектуре генератор легко адаптируется к расширению языка и добавлению новых конструкций.
7.2 Представление типов данных в оперативной памяти
Элементы таблицы идентификаторов располагаются в сегментах .data и .const языка ассемблера, что обеспечивает корректное размещение переменных и констант в памяти при выполнении программы. Соответствия между типами данных идентификаторов на языке AVA‑2025 и их представлением на уровне ассемблера приведены в таблице 7.1, что позволяет однозначно интерпретировать данные при трансляции и гарантирует корректность создаваемого машинного кода. 
Таблица 7.1 – Соответствия типов идентификаторов языка AVA-2025 и языка ассемблера 
Тип идентификатора на языке AVA-2025 	Тип идентификатора на языке ассемблера	Пояснение
number	word	Хранит целочисленный тип данных (2 байта). Значения от -32768 до 65535.
line	dword	Хранит указатель на начало строки. Строка должна завершаться символом нуль-терминатора.
char	byte	Хранит один символьный байт. При выводе формируется временная строка с нуль-терминатором.
В процессе генерации кода каждому идентификатору сопоставляется соответствующая директива ассемблера, определяющая его тип, область хранения и начальное значение.
7.3 Статическая библиотека
В языке AVA-2025 предусмотрена статическая библиотека StaticLibrary, которая компилируется в файл StaticLibrary.lib. Статическая библиотека содержит функции, написанные на языке C++ с использованием соглашения вызова __stdcall и блока extern "C" для обеспечения совместимости с ассемблерным кодом. Объявление функций статической библиотеки генерируется автоматически в секции EXTERN ассемблерного кода с помощью директивы PROTO. Библиотека подключается через директиву includelib с указанием абсолютного пути к файлу StaticLibrary.lib.
Таблица 7.3 – Функции статической библиотеки
Функция	Назначение
int __stdcall outlich(int value)	Вывод на консоль целочисленного значения value типа number. Используется генератором кода при обработке инструкции print для вывода чисел.
int __stdcall outrad(char* ptr)	Вывод на консоль строки, на которую указывает ptr. Используется для вывода строк типа line и символов типа char, а также для вывода символов перевода строки (writeline).
int __stdcall compare(char* ptr, char* a, char* b)	Сравнение двух строк a и b лексикографически. Возвращает: 0 если a < b, 1 если a == b, 2 если a > b. Параметр ptr используется как буфер, но не влияет на результат сравнения.
int __stdcall slength(char* buffer, char* str)	Вычисление длины строки str до нуль-терминатора. Параметр buffer используется как буфер, но не влияет на результат. Возвращает количество символов в строке.
char* __stdcall copystr(char* buffer, char* str)	Копирование строки str в буфер buffer (максимум 255 символов). Возвращает указатель на буфер. Используется для копирования строк.
int __stdcall rnd(char* ptr, int a, int b)	Генерация случайного числового значения в диапазоне от a до (a+b-1) включительно по формуле rand() % b + a. Использует текущее время как seed для генератора случайных чисел. Параметр ptr используется как буфер, но не влияет на результат.
Объявление функций статической библиотеки генерируется автоматически в секции EXTERN ассемблерного кода с указанием типов параметров. Все функции используют соглашение вызова __stdcall, при котором параметры передаются справа налево, а стек очищается вызываемой функцией.
7.4 Особенности алгоритма генерации кода
В языке AVA-2025 генерация кода строится на основе таблиц лексем и идентификаторов, полученных после лексического, синтаксического, семантического анализа и преобразования выражений в обратную польскую запись. 
Генератор кода последовательно обрабатывает лексемы из таблицы лексем и генерирует соответствующий ассемблерный код:
– для объявления переменных создаются директивы в сегменте .data с указанием типа (word для number, dword для line, byte для char);
– для литералов создаются константы в сегменте .const;
– для функций генерируются процедуры PROC с правильной передачей параметров через стек;
– для операций присваивания генерируется код вычисления выражения в обратной польской записи;
– для оператора print генерируется вызов соответствующей функции библиотеки (outlich для number, outrad для line и char);
– для цикла cycle генерируется код с использованием регистра CX для подсчета итераций и инструкции loop;
– для унарных операций (inc, dec, inv) генерируются соответствующие ассемблерные инструкции;
– в начале функции main устанавливается стековый фрейм (push ebp, mov ebp, esp), а в конце восстанавливается (mov esp, ebp, pop ebp) и вызывается _getch из библиотеки msvcrt.lib перед завершением программы для предотвращения немедленного закрытия консольного окна.
Общая схема работы генератора кода представлена на рисунке 7.2.
 
Рисунок 7.2 Структура генератора кода
7.5 Входные параметры генератора кода
На вход генератору кода поступают таблицы лексем и идентификаторов исходного код программы на языке AVA-2025. Результаты работы генератора кода выводятся в файл с расширением .asm.
7.6 Контрольный пример
Результат работы контрольного примера приведён на рисунке 7.2.

 
Рисунок 7.2 Результат работы программы на языке AVA-2025
Результат генерации ассемблерного кода на основе контрольного примера из приложения А приведен в приложении Д.
 
8. Тестирование транслятора
8.1 Тестирование проверки на допустимость символов
В языке AVA-2025 не разрешается использовать запрещённые входным алфавитом символы. Результат использования запрещённого символа показан в таблице 8.1.
Таблица 8.1 - Тестирование проверки на допустимость символов
Исходный код	Диагностическое сообщение
main [ ~ ]	Ошибка при чтении из входного файла
Ошибка 200: Лексический анализ: обнаружен недопустимый символ, строка 1
main 
[ 
	print "test
]	Ошибка при чтении из входного файла
Ошибка 311: Синтаксический анализ: пропущена символ '"'. Возможно, не указан начальный/конечный символ, строка 3
В ходе тестирования ошибок выявлено не было
8.2 Тестирование лексического анализатора
На этапе лексического анализа в языке AVA-2025 могут возникнуть ошибки, описанные в пункте 3.7. Результаты тестирования лексического анализатора показаны в таблице 8.2. 
Таблица 8.2 - Тестирование лексического анализатора 
Исходный код	Диагностическое сообщение
main 
[ 
	test123
]	Ошибка на этапе лексического анализатора
Ошибка 201: Лексический анализ: обнаружен недопустимый символ, строка 3
main 
[ 
	var test;
]	Ошибка на этапе лексического анализатора
Ошибка 304: Синтаксический анализ: в инструкции отсутствует название типа, строка 3
main 
[ 
	number var test;
	number var test;
]	Ошибка на этапе лексического анализатора
Ошибка 305: Синтаксический анализ: функция продублирована идентификатор, строка 4

Продолжение таблицы 8.2
main 
[ 
number test;
]	Ошибка на этапе лексического анализатора
Ошибка 303: Синтаксический анализ: в инструкции не указан тип идентификатора, строка 3

number function FindMaxLen(line param x, line param y)[]
[]	Ошибка 301: Синтаксический анализ: отсутствует точка входа main
main []
main 
[
number var test;
]	Ошибка 302: Синтаксический анализ: дублирование объявления точки входа main
После анализа представленных результатов можно сделать вывод, что лексический анализатор корректно обрабатывает как типичные, так и ошибочные входные данные, обеспечивая надёжную фильтрацию некорректных конструкций на раннем этапе трансляции.
8.3 Тестирование синтаксического анализатора
На этапе синтаксического анализа в языке AVA-2025 могут возникнуть ошибки, описанные в пункте 4.6. Результаты тестирования синтаксического анализатора показаны в таблице 8.3.
Таблица 8.3 - Тестирование синтаксического анализатора
Исходный код	Диагностическое сообщение
function main
[
	number var test;
]	Ошибка 600: Синтаксический анализ: ошибка в структуре программы (правило S), строка 1
main
[
	return 1;
]	Ошибка 610: Синтаксический анализ: ошибка в операторе (правило K), строка 4
main
[
	number var test;
	test = 1 + - 2;
]	Ошибка 609: Синтаксический анализ: ошибка в выражении (правило W), строка 4
number function FindMaxLen(line param x, )
[

] main []	Ошибка 601: Синтаксический анализ: ошибка в параметрах функции (правило P), строка 1
Продолжение таблицы 8.3
main 
[
	cycle "test"
]	Ошибка 317: Семантический анализ: неверный тип параметра инструкции, строка 3
main 
[
	number line var test;
]	Ошибка 304: Синтаксический анализ: в инструкции отсутствует название типа, строка 3
main 
[
	number var test = "string";
]	Ошибка 314: Семантический анализ: несоответствие типов данных при присваивании, строка 3
number function FindMax(number param x)
[ return 1;]
main 
[
	number var res; res = FindMax(1, )]	Ошибка 308: Семантический анализ: несоответствие количества параметров функции, строка 6
После анализа представленных данных можно отметить, что синтаксический анализатор корректно обрабатывает как валидные конструкции, так и различные типы ошибок, обеспечивая надёжную проверку структуры программы перед переходом к этапу семантического анализа.
8.4 Тестирование семантического анализатора
Итоги тестирования семантического анализатора на корректное обнаружение семантических ошибок приведены в таблице 8.4.
Таблица 8.4 - Тестирование семантического анализатора
Исходный код	Текст сообщения
main[
	number var x = 125;
x = x + "IAS2025";
]	Ошибка на этапе Семантического анализатора
Ошибка 314: Семантический анализ: несоответствие типов данных при присваивании, строка 3
main[
number var x;
x = 5 / 0;
]	Ошибка на этапе Семантического анализатора
Ошибка 318: Семантический анализ: деление на ноль, строка 3
main[
	line var y;
y = "test2" + "test3";
]	Ошибка на этапе Семантического анализатора
Ошибка 316: Семантический анализ: недопустимая операция со строковым типом, строка 3
line function Test(number param x)
[
	return 0;
]
main []	Ошибка на этапе Семантического анализатора
Ошибка 315: Семантический анализ: несоответствие типа возвращаемого значения функции, строка 3
number function Test(number param x)
[return 0;]
main 
[
	number var temp;
	temp = Test("test");
]		Ошибка на этапе Семантического анализатора
Ошибка 309: Семантический анализ: несоответствие типа параметра функции, строка 6
number function Test(number param x)
[return 0;]
main 
[
	number var temp;
	temp = Test(1, 2);
]		Ошибка на этапе Семантического анализатора
	Ошибка 308: Семантический анализ: несоответствие количества параметров функции, строка 6

Семантический анализ в языке AVA-2025 содержит множество проверок по семантическим правилам, описанным в пункте 1.16.











 
Заключение
В процессе выполнения курсовой работы создан транслятор и генератор кода для языка программирования AVA-2025, включающий все требуемые модули. В результате были реализованы ключевые цели данной курсовой работы:
– определена спецификация языка AVA-2025;
– созданы конечные автоматы и основные алгоритмы на их базе для корректной работы лексического анализатора;
– выполнена программная реализация лексического анализатора, который распознает допустимые цепочки разработанного языка;
– создана контекстно-свободная грамматика в нормальной форме Грейбах для описания синтаксически корректных конструкций языка;
– выполнена программная реализация синтаксического анализатора;
– создан семантический анализатор, выполняющий проверку используемых инструкций на соответствие семантическим правилам;
– создан транслятор кода на язык ассемблера;
– выполнено тестирование всех перечисленных компонентов.
Итоговая версия языка AVA-2025 содержит:
– 3 типа данных (number - 2 байта, line - строка до 255 символов, char - 1 байт);
– операторы вывода (print для вывода значений, writeline для перевода строки);
– унарные операции (inc - инкремент, dec - декремент, inv - инверсия);
– возможность использования 6 функций стандартной библиотеки StaticLibrary (outlich, outrad, compare, slength, copystr, rnd);
– 5 арифметических операторов для вычисления выражений (+, -, *, /, %);
– побитовые операции сдвига ({ - сдвиг влево, } - сдвиг вправо);
– пользовательские функции с параметрами и возвращаемыми значениями;
– оператор цикла cycle с фиксированным числом повторений;
– упорядоченная и категоризированная система обработки ошибок пользователя.
Выполненная работа дала возможность приобрести требуемые знания о структурах и процессах, применяемых при создании трансляторов, а также понять основные различия и достоинства различных подходов к трансляции. 
 
Список использованных источников
1. Ахо, А. Компиляторы: принципы, технологии и инструменты / А. Ахо, Р. Сети, Дж. Ульман. – M.: Вильямс, 2003. – 768с.
2. Ахо, А. Теория синтаксического анализа, перевода и компиляции /А. Ахо, Дж. Ульман. – Москва : Мир, 1998. – Т. 2 : Компиляция. - 487 с. 
3. Герберт, Ш. Справочник программиста по C/C++ / Шилдт Герберт.  - 3-е изд. – Москва : Вильямс, 2003. - 429 с.
4. Прата, С. Язык программирования С++. Лекции и упражнения / С. Прата. – М., 2006 — 1104 c.
5. Страуструп, Б. Принципы и практика использования C++ / Б. Страуструп – 2009 – 1238 с
 
Приложение А
number function powloop(number start)
[
    var number res;
    res = start;
    cycle 5 [
        res = res * res;
    ]
    return res;
]

main
[
    var number x;
    var number y;
    var number z;
    var char c;
    var line sone;
    var line stwo;
    var number acc;

    x = 5;
    y = 3;
    z = -2;
    c = 'b';
    sone = "hello";
    stwo = "world";

    inc x;
    dec y;
    inv z;
    acc = 0;

    z = x + y;
    print z; writeline;

    print sone; writeline;
    print stwo; writeline;
    print c; writeline;

    var number pwr;
    pwr = powloop(2);
    print pwr; writeline;
]
Листинг 1 – исходный код программы на языке AVA-2025
 
Приложение Б
 
Рисунок 1. Таблица идентификаторов после контрольного примера
1	tfi(tpi,tpi){
2	tvi=i#i;
3	ri;
4	}
5	
6	xfi(tpi,tpi){
7	xvi;
8	tvi=i(i);
9	tvi=i(i);
10	?(i&i)
11	:{
12	i=o;
13	}
14	!{
15	i=o;
16	}
17	ri;
18	}
19	xfi(tpi){
20	xvi;
21	tvi=i#l;
22	?(i&l)
23	:{
24	i=o;
25	}
26	!{
27	i=o;
28	}
29	ri;
30	}
31	m
32	{
33	wl;
34	tvi=i();
35	wi;
36	tvi=l;
37	wl;
38	wi;
39	tvi=l;
40	wl;
41	wi;
42	tvi=i(i,i);
43	wl;
44	wi;
45	cvi=k;
46	tvi=i(i);
47	wl;
48	wi;
49	i=inl;
50	wl;
51	wi;
52	i=ibl;
53	wl;
54	wi;
55	tvi=l;
56	~(l){
57	wi;
58	i=i#l;
59	}
60	~(i>l){
61	wl;
62	wi;
63	i=i#l;
64	}
65	
66	wl;
67	tvi=i(i,i);
68	wi;
69	
70	tvi=l;
71	tvi=l;
72	
73	wl;
74	tvi=i(i,i,l);
75	wi;
76	wi;
77	wi;
78	
79	xvi=i(i,i);
80	wi;
81	tvi=l;
82	wl;
83	wi;
84	i=i(i,l);
85	wl;
86	wi;
87	i=i(i);
88	wl;
89	wi;
90	xvi=i(i);
91	wi;
92	tvi=l;
93	wi;
94	}$

Листинг 1 – Таблица лексем для контрольного примера      
Приложение В
		Greibach greibach(NS('S'), TS('$'), 13,
	Rule(NS('S'), GRB_ERROR_SERIES + 0, // Неверная структура программы
		5,	// m{N}S | tfi(F){NrU;}S | cfi(F){NrU;}S | пустой переход
		Rule::Chain(5, TS('m'), TS('{'), NS('N'), TS('}'), NS('S')),
		Rule::Chain(13, TS('t'), TS('f'), TS('i'), TS('('), NS('F'), TS(')'), TS('{'), NS('N'), TS('r'), NS('U'), TS(';'), TS('}'), NS('S')),
		// Добавлено правило для функций типа char (c)
		Rule::Chain(13, TS('c'), TS('f'), TS('i'), TS('('), NS('F'), TS(')'), TS('{'), NS('N'), TS('r'), NS('U'), TS(';'), TS('}'), NS('S')),
		Rule::Chain(13, TS('x'), TS('f'), TS('i'), TS('('), NS('F'), TS(')'), TS('{'), NS('N'), TS('r'), NS('U'), TS(';'), TS('}'), NS('S')),
		Rule::Chain()
	),
	Rule(NS('N'), GRB_ERROR_SERIES + 1, 9,
		Rule::Chain(),  // ← ПУСТОЕ ПРАВИЛО ПЕРВЫМ!
		Rule::Chain(4, TS('t'), NS('Y'), TS(';'), NS('N')),
		Rule::Chain(4, TS('c'), NS('Y'), TS(';'), NS('N')),
		Rule::Chain(5, TS('i'), TS('='), NS('E'), TS(';'), NS('N')),
		Rule::Chain(4, TS('x'), NS('Y'), TS(';'), NS('N')),
		Rule::Chain(4, TS('w'), NS('E'), TS(';'), NS('N')),
		Rule::Chain(4, TS('~'), NS('K'), NS('Z'), NS('N')),
		Rule::Chain(6, TS('~'), TS('('), TS('l'), TS(')'), NS('Z'), NS('N')),
		Rule::Chain(4, TS('?'), NS('K'), NS('J'), NS('N')),
		Rule::Chain(4, TS('i'), NS('M'), TS(';'), NS('N'))
	),
	Rule(NS('E'), GRB_ERROR_SERIES + 2,		// Ошибка в выражении
		6, // iM | lM | kM | (E)M | i(W)M
		Rule::Chain(2, TS('i'), NS('M')),
		Rule::Chain(2, TS('l'), NS('M')),
		// Добавлено для символьного литерала (k)
		Rule::Chain(2, TS('o'), NS('M')),
		Rule::Chain(2, TS('k'), NS('M')),
		Rule::Chain(4, TS('('), NS('E'), TS(')'), NS('M')),
		Rule::Chain(5, TS('i'), TS('('), NS('W'), TS(')'), NS('M'))
	),
	Rule(NS('M'), GRB_ERROR_SERIES + 2, 4,
		Rule::Chain(2, TS('#'), NS('E')),
		Rule::Chain(2, TS('b'), NS('E')),  // <<
Rule::Chain(2, TS('n'), NS('E')),  // >>
		Rule::Chain()
	),
	Rule(NS('F'), GRB_ERROR_SERIES + 3,		// Ошибка в параметрах при определении функции
		5, // tP | cP | tP,F | cP,F
		Rule::Chain(2, TS('t'), NS('P')),
		// Добавлено для параметров типа char
		Rule::Chain(2, TS('c'), NS('P')),
		Rule::Chain(4, TS('t'), NS('P'), TS(','), NS('F')),
		// Добавлено для параметров типа char (продолжение списка)
		Rule::Chain(4, TS('c'), NS('P'), TS(','), NS('F')),
		Rule::Chain(4, TS('x'), NS('P'), TS(','), NS('F'))
	),
	Rule(NS('P'), GRB_ERROR_SERIES + 3,		// Ошибка в параметрах при определении функции
		1, // pi
		Rule::Chain(2, TS('p'), TS('i'))
	),
	Rule(NS('W'), GRB_ERROR_SERIES + 4,		// Ошибка в параметрах при вызове функции
		9, // i | l | k | i,W | l,W | k,W
		Rule::Chain(1, TS('i')),
		Rule::Chain(1, TS('l')),
		// Добавлено для char литерала (k)
		Rule::Chain(1, TS('k')),
		Rule::Chain(1, TS('o')),
		Rule::Chain(3, TS('i'), TS(','), NS('W')),
		Rule::Chain(3, TS('l'), TS(','), NS('W')),
		// Добавлено для char литерала в списке (k)
		Rule::Chain(3, TS('k'), TS(','), NS('W')),
		Rule::Chain(3, TS('o'), TS(','), NS('W')),
		Rule::Chain()
	),
	Rule(NS('U'), GRB_ERROR_SERIES + 5, 	// Только литерал или идентификатор
		11,	// l | k | i ...
		Rule::Chain(1, TS('l')),
		// Добавлено k
		Rule::Chain(1, TS('k')),
		Rule::Chain(1, TS('i')),
		Rule::Chain(2, TS('l'), NS('U')),
		Rule::Chain(2, TS('i'), NS('U')),
		Rule::Chain(3, TS('i'), TS(','), NS('U')),
		Rule::Chain(3, TS('l'), TS(','), NS('U')),
		// Добавлено k в списки
		Rule::Chain(3, TS('k'), TS(','), NS('U')),
		Rule::Chain(2, TS('#'), TS('l')),
		// Добавлено k с оператором
		Rule::Chain(2, TS('#'), TS('k')),Rule::Chain(3, TS('#'), TS('l'), NS('U')),
		Rule::Chain(4, TS('#'), TS('l'), TS(','), NS('U'))
	),
	Rule(NS('J'), GRB_ERROR_SERIES + 6, 	// Ошибка при условном переходе
		2,	// :{N} | :{N}!{N}
		Rule::Chain(4, TS(':'), TS('{'), NS('N'), TS('}')),
		Rule::Chain(8, TS(':'), TS('{'), NS('N'), TS('}'), TS('!'), TS('{'), NS('N'), TS('}'))
	),
	Rule(NS('Y'), GRB_ERROR_SERIES + 7, 	// Ошибка при определении переменной
		5,	// vi || vi = L
		Rule::Chain(2, TS('v'), TS('i')),
		Rule::Chain(4, TS('v'), TS('i'), TS('='), NS('L')),
		Rule::Chain(5, TS('v'), TS('i'), TS('='), NS('E'), NS('M')), // для выражений: vi = a >> 3
		Rule::Chain(4, TS('v'), TS('i'), TS('='), TS('k')),
		Rule::Chain(4, TS('v'), TS('i'), TS('='), TS('o'))
	),

	Rule(NS('K'), GRB_ERROR_SERIES + 8, 	// Ошибка при определении условия перехода
		4,	// (U<U) | (U>U)
		Rule::Chain(5, TS('('), NS('U'), TS('<'), NS('U'), TS(')')),
		Rule::Chain(5, TS('('), NS('U'), TS('>'), NS('U'), TS(')')),
		Rule::Chain(5, TS('('), NS('U'), TS('&'), NS('U'), TS(')')),
		Rule::Chain(5, TS('('), NS('U'), TS('^'), NS('U'), TS(')'))
	),
	Rule(NS('L'), GRB_ERROR_SERIES + 9, 18, // увеличиваем с 12 до 14
		Rule::Chain(1, TS('i')),
		Rule::Chain(1, TS('l')),
		Rule::Chain(1, TS('k')),
		Rule::Chain(1, TS('o')),
		Rule::Chain(4, TS('i'), TS('('), NS('U'), TS(')')),
		Rule::Chain(3, TS('i'), TS('('), TS(')')),
		Rule::Chain(2, TS('#'), TS('i')),
		Rule::Chain(2, TS('#'), TS('l')),
		Rule::Chain(2, TS('#'), TS('k')),
		Rule::Chain(2, TS('#'), TS('o')),
		Rule::Chain(3, TS('#'), TS('i'), NS('L')),
		Rule::Chain(3, TS('#'), TS('l'), NS('L')),
		Rule::Chain(3, TS('#'), TS('k'), NS('L')),
		Rule::Chain(3, TS('#'), TS('o'), NS('L')),
		Rule::Chain(2, TS('i'), NS('L')),
Rule::Chain(2, TS('l'), NS('L')),
		Rule::Chain(2, TS('o'), NS('L')),

		Rule::Chain(3, NS('E'), NS('M'))  // ← ДОБАВИЛИ: выражение с оператором
	),
	Rule(NS('Z'), GRB_ERROR_SERIES + 10, 	//ошибка в теле цикла
		1,
		Rule::Chain(3, TS('{'), NS('N'), TS('}'))
	)
);
Листинг 1 – Грамматика языка AVA-2025

	struct MFST // магазинный автомат
	{
		enum RC_STEP //код возврата функции step
		{
			NS_OK,			// найдено правило и цепочка, цепочка записана в стек 
			NS_NORULE,		// не найдено правило грамматики (ошибка в грамматике)
			NS_NORULECHAIN,	// не найдена походящая цепочка правила (ошибка в исходном коде)
			NS_ERROR,		// неизвесный нетерминальный символ грамматики
			TS_OK,			// тек. символ ленты == вершине стека, продвинулась лента, pop стека
			TS_NOK,			// тек. символ ленты != вершине стека, восстановленно состояние 
			LENTA_END,		// теущая позиция ленты >= lenta_size 
			SURPRISE		// неожиданный код возврата (ошибка в step)
		};

		struct MFST_Diagnosis	// диагностика
		{
			short	posInLent;		// позиция на ленте 
			RC_STEP	rc_step;			// код завершения шага 
			short	ruleNum;			// номер правила 	short	nrule_chain;		// номер цепочки правила
			MFST_Diagnosis();
			MFST_Diagnosis(short posInLent, RC_STEP rc_step, short ruleNum, short ruleChainNum);
		} diagnosis[MFST_DIAGN_NUMBER]; // последние самые глубокие сообщения

		GRBALPHABET* lenta;					// перекодированная (TS/NS) лента (из LEX)
		short currentPosInLent;				// текущая позиция на ленте
		short currentRule;					// номер текущего правила
		short currentRuleChain;				// номер текущей цепочки, текущего правила
		short lenta_size;					// размер ленты
		GRB::Greibach grebach;				// грамматика Грейбах
		LT::LexTable lexTable;						
		MFSTSTSTACK st;						// стек автомата
		std::stack<MFSTState> storestate;	// стек для сохранения состояний

		MFST();
		MFST(const LT::LexTable& lexTable,GRB::Greibach grebach);

		char* getCSt(char* buf);								//получить содержиое стека
		char* getCLenta(char* buf, short pos, short n = 25);	//лента: n символов, начиная с pos
		char* getDiagnosis(short n, char* buf);					//получить n-ую строку диагностики или '\0'
		
		bool savestate(std::ostream* stream);	//сохранить состояние автомата
		bool resetstate(std::ostream* stream);	//восстановить состояние автомата
		bool push_chain(GRB::Rule::Chain chain);

		RC_STEP step(std::ostream* stream);		//выполнить шаг автомата
		bool start(std::ostream* stream);		//запустить автомат
		bool savedDiagnosis(RC_STEP prc_step);

		void printRules(std::ostream* stream);	//вывести последовательность правил
struct Deducation		// вывод
		{
			short stepsCount;			// количество шагов в выводе
			short* nRules;				// номер правила грамматики
			short* nChainsOfRules;		// номер цепочек правил грамматики

			Deducation()
			{
				this->stepsCount = 0;
				this->nRules = 0;
				this->nChainsOfRules = 0;
			}
		}deducation;

		bool saveoutputTree();			// сохранить дерево вывода
	};
Листинг 2 – структура магазинного автомата
struct Greibach // грамматика Грейбаха
	{
		short size;				// количество правил 
		GRBALPHABET startN;		// стартовый символ
		GRBALPHABET stbottomT;  // дно стека
		Rule* rules;			// множество правил

		Greibach(){
			size = 0;
			startN = 0;
			stbottomT = 0;
			rules = 0;};
		Greibach(GRBALPHABET pstartN,	// стартовый символ
			GRBALPHABET pstbottomT,		// дно стека
			short psize,				// количество правил
			Rule r, ...);				// правила
		short getRule(				// получить правило
			GRBALPHABET pnn,		// левый символ правила
			Rule& prule);			// возвращаемое правило 

		Rule getRule(short n);		// получить правило по номеру
	}; 
Листинг 3 – Структура грамматики Грейбаха


129 : S->m{N}S            
131 : N->tY;N             
132 : Y->vi=L             
135 : L->i()              
139 : N->wE;N             
140 : E->iM               
141 : M->                 
142 : N->tY;N             
143 : Y->vi=L             
146 : L->l                
148 : N->wE;N             
149 : E->lM               
150 : M->                 
151 : N->wE;N             
152 : E->iM               
153 : M->                 
154 : N->tY;N             
155 : Y->vi=L             
158 : L->l                
160 : N->wE;N             
161 : E->lM               
162 : M->                 
163 : N->wE;N             
164 : E->iM               
165 : M->                 
166 : N->tY;N             
167 : Y->vi=L             
170 : L->i(U)             
172 : U->i,U              
174 : U->i                
177 : N->wE;N             
178 : E->lM               
179 : M->                 
180 : N->wE;N             
181 : E->iM               
182 : M->                 
183 : N->cY;N             
184 : Y->vi=L             
187 : L->k                
189 : N->tY;N             
190 : Y->vi=L             
193 : L->i(U)             
195 : U->i                
198 : N->wE;N             
199 : E->lM               
200 : M->                 
201 : N->wE;N             
202 : E->iM               
203 : M->                 
204 : N->i=E;N            
206 : E->iM               
207 : M->nE               
208 : E->lM               
209 : M->                 
210 : N->wE;N             
211 : E->lM               
212 : M->                 
213 : N->wE;N             
214 : E->iM               
215 : M->                 
216 : N->i=E;N            
218 : E->iM               
219 : M->bE               
220 : E->lM               
221 : M->                 
222 : N->wE;N             
223 : E->lM               
224 : M->                 
225 : N->wE;N             
226 : E->iM               
227 : M->                 
228 : N->tY;N             
229 : Y->vi=L             
232 : L->l                
234 : N->~(l)ZN           
238 : Z->{N}              
239 : N->wE;N             
240 : E->iM               
241 : M->                 
242 : N->i=E;N            
244 : E->iM               
245 : M->#E               
246 : E->lM               
247 : M->                 
248 : N->                 
249 : N->~KZN             
250 : K->(U>U)            
251 : U->i                
253 : U->l                
255 : Z->{N}              
256 : N->wE;N             
257 : E->lM               
258 : M->                 
259 : N->wE;N             
260 : E->iM               
261 : M->                 
262 : N->i=E;N            
264 : E->iM               
265 : M->#E               
266 : E->lM               
267 : M->                 
268 : N->                 
269 : N->wE;N             
270 : E->lM               
271 : M->                 
272 : N->tY;N             
273 : Y->vi=L             
276 : L->i(U)             
278 : U->i,U              
280 : U->i                
283 : N->wE;N             
284 : E->iM               
285 : M->                 
286 : N->tY;N             
287 : Y->vi=L             
290 : L->l                
292 : N->tY;N             
293 : Y->vi=L             
296 : L->l                
298 : N->wE;N             
299 : E->lM               
300 : M->                 
301 : N->tY;N             
302 : Y->vi=L             
305 : L->i(U)             
307 : U->i,U              
309 : U->i,U              
311 : U->l                
314 : N->wE;N             
315 : E->iM               
316 : M->                 
317 : N->wE;N             
318 : E->iM               
319 : M->                 
320 : N->wE;N             
321 : E->iM               
322 : M->                 
323 : N->xY;N             
324 : Y->vi=L             
327 : L->i(U)             
329 : U->i,U              
331 : U->i                
334 : N->wE;N             
335 : E->iM               
336 : M->                 
337 : N->tY;N             
338 : Y->vi=L             
341 : L->l                
343 : N->wE;N             
344 : E->lM               
345 : M->                 
346 : N->wE;N             
347 : E->iM               
348 : M->                 
349 : N->i=E;N            
351 : E->i(W)M            
353 : W->i,W              
355 : W->l                
357 : M->                 
358 : N->wE;N             
359 : E->lM               
360 : M->                 
361 : N->wE;N             
362 : E->iM               
363 : M->                 
364 : N->i=E;N            
366 : E->i(W)M            
368 : W->i                
370 : M->                 
371 : N->wE;N             
372 : E->lM               
373 : M->                 
374 : N->wE;N             
375 : E->iM               
376 : M->                 
377 : N->xY;N             
378 : Y->vi=L             
381 : L->i(U)             
383 : U->i                
386 : N->wE;N             
387 : E->iM               
388 : M->                 
389 : N->                 
390 : S->   
Листинг 4 – дерево разбора синтаксиеского анализатора
 
Приложение Г
.586							; система команд (процессор Pentium)
.model flat, stdcall			; модель памяти, соглашение о вызовах
includelib kernel32.lib
includelib libucrt.lib
includelib StaticLib.lib

ExitProcess PROTO: dword		; прототип функции для завершения процесса Windows

EXTRN lenght: proc
EXTRN write_int: proc
EXTRN write_str : proc
EXTRN copy: proc
EXTRN getLocalTimeAndDate: proc
EXTRN random: proc
EXTRN squareOfNumber: proc
EXTRN factorialOfNumber: proc
EXTRN powNumber: proc

EXTRN asciiCode: proc

.stack 4096

.const							; сегмент констант - литералы
nulError byte 'error divided by zero', 0
nul sdword 0, 0

	L0 byte 1
L1 byte 0
	L2 sdword 2
	L3 sdword 0
	L4 sdword 10
	L5 byte "Переменная a", 0
	L6 sdword 50
	L7 byte "Переменная b", 0
	L8 byte "Случайное число от a до b", 0
	L9 byte 'c', 0
	L10 byte "Код ch", 0
	L11 byte "a после сдвига вправо на 2", 0
	L12 byte "b после сдвига влево на 2", 0
	L13 sdword 1
L14 byte "new iter", 0	
L15 byte "Выполнение функции get_sum(a, b)", 0
	L16 byte "Hello, my name is Arseniy", 0
	L17 byte "Hello, my name is Alex", 0
	L18 byte "Первых три элемента, скопированных из первой строки во вторую :", 0
	L19 sdword 3
	L20 byte "test:", 0
	L21 byte "test после powNumber:", 0
	L22 byte "Факториал переменной test:", 0
.data							; сегмент данных - переменные и параметры
_true_str db 'true', 0
_false_str db 'false', 0

	res_get_sum sdword 0
	res_IsStringsEquals byte 0
lenOne_IsStringsEquals sdword 0
	lenTwo_IsStringsEquals sdword 0
	res_IsEven byte 0
	buf_IsEven sdword 0
	date_main dword ?
	a_main sdword 0
	b_main sdword 0
	rnd_main sdword 0
	ch_main byte 0
	code_main sdword 0
	iter_main sdword 0
	sum_main sdword 0
	stringOne_main dword ?
	stringTwo_main dword ?
	ns_main dword ?
	flag_main byte 0
	test_main sdword 0
	evenFlag_main byte 0
.code							; сегмент кода

;----------- get_sum ------------
get_sum PROC,	argOne_get_sum : sdword, argTwo_get_sum : sdword  
; --- сохранить регистры ---
push ebx
push edx
; ----------------------
push argOne_get_sum
push argTwo_get_sum
pop ecx
pop eaxadd eax, ecx

push eax
pop res_get_sum

; --- восстановить регистры ---
pop edx
pop ebx
; -------------------------
mov eax, res_get_sum
ret
get_sum ENDP
;------------------------------


;----------- IsStringsEquals ------------
IsStringsEquals PROC,	StringOne_IsStringsEquals : dword, StringTwo_IsStringsEquals : dword  
; --- сохранить регистры ---
push ebx
push edx
; ----------------------
push StringOne_IsStringsEquals
call lenght
push eax
pop lenOne_IsStringsEquals

push StringTwo_IsStringsEquals
call lenght
push eax
pop lenTwo_IsStringsEquals

mov edx, lenOne_IsStringsEquals
cmp edx, lenTwo_IsStringsEquals

jz true0
jnz false0	
true0:
mov al, 1
mov res_IsStringsEquals, al
jmp next0
next0:

; --- восстановить регистры ---
pop edx
pop ebx
; -------------------------
mov al, res_IsStringsEquals
movzx eax, al
ret
IsStringsEquals ENDP
;------------------------------


;----------- IsEven ------------
IsEven PROC,	arg_IsEven : sdword  
; --- сохранить регистры ---
push ebx

push edx
; ----------------------
push arg_IsEven
push L2
pop ecx
pop eax
cdq
idiv ecx
push edx
pop buf_IsEven
mov edx, buf_IsEven
cmp edx, L3
jz true1
jnz false1
true1:
mov al, 1
mov res_IsEven, al
jmp next1
false1:
mov al, 0
mov res_IsEven, al
next1:
; --- восстановить регистры ---
pop edx
pop ebx
Листинг 1 Исходный код на языке ассемблера для контрольного примера


